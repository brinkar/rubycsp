h1. Ruby CSP

*"CSP (Communicating Sequential Processes)":http://en.wikipedia.org/wiki/Communicating_sequential_processes library for Ruby*

A young library introducing CSP-like concurrent programming to the Ruby world.

h2. Introduction

First of all, be warned that this library still lacks some of very basic CSP concepts. It only works with Ruby 1.9, and has only been tested on Linux.

The library has been influenced by other CSP implementations including PyCSP (for Python), JCSP (for Java), C++ CSP and Occam with some other concepts introduced to make it more Ruby-ish wherever possible. You can check out the syntax and behaviour of the library by looking at the files in the examples/ and test/ directories. Later on, a more formal tutorial and some API-docs might be created.

h2. Features

*Currently implemented featues include:*

* Processes. Implemented using Ruby 1.9 fibers.
* Process maps for running processes in parallel.
* Process labelling for easy reusing of processes.
* Channels. Anything (one, any, any natural number) to anything.
* Poisoning of channels.
* Read/write restriction using channel ends.
* Some simplifying functions for doing common stuff easily.

*Planned features:*

* Alternative class. Reading/writing from/to one of more channels depending on the state of the system.
* OS processes. Distribute CSP processes (fibers) on a number of Ruby processes, making it possible to take advantage of multiple CPU cores.
* Transparent network support. Channels are shared on a TCP socket so that any process can run anywhere on the network.
* Native processes. Creating an easy way to implement your processes in C/++ or Fortran, possibly using the RubyInline gem.
* Visualization and inspection. Automatic graph creation for inspecting your CSP network.
* Logging. Something like CSP traces could be implemented for generic logging and inspection of the state of a system.
* Suspending/resuming processes and networks. If it's actually usable for anything.
* Mobility. Look into pi-calculus and see if some of the concepts of process and channel mobility could be implemented.
